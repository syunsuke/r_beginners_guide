# コンソールとコマンド

## コマンド

プロンプトに対して渡すコマンドの基本形を見てみましょう。

### 四則演算

プロンプトに対して、通常の四則演算式を入力すれば、
電卓変りに使うことが出来ます。

```{r}
# 四則演算
(350 + 120) * (100 - 20) / (10 * 10)
```

### 関数

通常のコマンドは、Rの**関数**を入力して実行します。
まずは、現在の時間を教えてくれる`date()`という関数を試してみましょう。

```{r}
# 現在の時刻を表示する関数
date()
```

関数には決まったパターンがあります。
`date()`を見て把握できる通り、関数は、必ず、関数名とそれに続く括弧から成り立っています。
関数名と括弧の間にスペースを入れてはいけません。
上記の例である`date()`は、かっこの中に何も書いてありませんでしたが、
括弧の中には**引数**と呼ばれるものが入ることもあります。
引数は、「ひきすう」と読みます。

では、引数をとる関数を試してみましょう。`sum()`関数は、引数として渡された数字の合計を返してくれます。


```{r}
# 引数として渡された数字を合計するsum()関数
sum(1, 2, 3, 4, 5)
```

この様に複数にカンマを使って区切ることで、関数には複数の引数を渡すことが出来ます。

関数の引数は、その各関数によって、どのような引数を取るのかが決まっています。
また、その引数の場所に意味があったり、
引数を省略すると自動的に既定値（デフォルト値）をとることもあります。

このような引数に関するルールについては、のちに学習することになりますが、
ここでは、まず、関数は引数を取ることがあるという基本的な事を把握できれば十分です。


## 履歴機能

先のsum()関数では、1から5までの数字を合計しました。
次は、１から6までの数字を合計したいとしましょう。
実際の計算作業においても、
一度行った計算の一部を調整して、再度、似たような計算を行うこともあると思います。
そんな、作業をサポートしてくれるのが履歴機能です。

コンソールにフォーカスがある状態で、カーソルキーの**上矢印"↑"をキー**押してください。
（図\@ref(fig:cursorkey001)）
前回実行したコマンドがプロンプト上に入力された状態になりましたか？
何度もこのカーソルの上矢印キーを押すと、
どんどん、前に入力して実行したコマンドに変わっていくはずです。
これを**履歴機能**と呼びます。
今度は、**下矢印"↓"キー**を押して下さい。
そうです、行き過ぎたら戻ればよいわけです。

```{r cursorkey001, echo=FALSE, out.width="70%", fig.cap="キーボードのカーソルキー"}
knitr::include_graphics("images/cursorkey001.jpg")
```

このように、面倒で複雑なコマンドも１度入力してしまえば、
いつでも指一本で簡単に呼び出せるようになります。
ですから、似たようなコマンドは１から打ち込むことなく、
以前実行したコマンドを再度呼び出し、
必要な部分のみを修正するだけでよくなるので、入力が格段に簡単になります。

では、1から6までの合計値を計算してみてください。

```{r}
# 履歴を活用して1から6の合計値を計算する
sum(1, 2, 3, 4, 5, 6)
```

## 変数と代入

プログラミングをしたことが無い人ならば、
まずは単純に、変数とは名前の付いたデータの入れ物だと考えればＯＫです。

a という変数に、10という数を入れるならば、次のように書きます。

```{r}
# 変数に値を代入する
a <- 10
```

`<-`の部分は、変数にデータを代入する代入記号です。
`<`（小なり記号）と、`-`（ハイフン）の２文字を使って矢印のような形を書き込むことになりますが、
RStudio上では、Altキーと`-`ハイフンキーを同時押しすれば、一発で書き込むことが出来ます。

変数への代入を行うと、その代入された値はコンピューターの中に保持されます。
そして、RStudioは変数とその値についての情報を
右上ペインの`Environment`タブにまとめて表示してくれます。（図\@ref(fig:envtab001)）

```{r envtab001, echo=FALSE, out.width="70%", fig.cap="Environmentタブ"}
knitr::include_graphics("images/environmenttab001.png")
```



変数は、この保持する機能をもっているということを意識しましょう。
先ほど、1から6までの数字の合計値を計算しました。
しかし、実は、計算をして結果を表示させただけであり、
その結果を改めて他の計算に使おうと思っても既にそのデータはパソコン上にありません。
そこで、何らかの計算を行い、その計算結果を後から別の場所で使いたい場合には、
変数を使ってデータを保持しておく必要があるのです。

```{r}
# 計算結果を代入する
res <- sum(1, 2, 3, 4, 5, 6)
```

この変数resの内容は、右上ペインのEnvironmentタブに表示されている変数一覧で確認できるはずです。

では、1から6までの数字が合計されているので、それを使って、1から6までの数字の平均を求めてみましょう。
合計された数字をその個数6で割ればよいので、次のようになります。

```{r}
# 計算結果を使って更に計算する
res / 6
```

**変数**の性質については、これからたくさん学ぶべきものが出てきます。
しかし、まずは、代入記号を使って値を代入して、
その値を保持させ、これを後から使うことが出来るという点を把握しましょう。


## ベクトル

ベクトルという単語を聞くと、高校数学で習った「方向と大きさを持った量」を思い浮かべるかもしれませんが、
**Rでいうベクトルは、単なるデータの集合であり**、高校数学のベクトルとは異なります。
もう一つ、ベクトルの発音で悩む必要はありません。日本語では**ベクトル**で大丈夫です。

プログラミングの世界では、**ある一連のデータ**を扱うことが非常に多いです。
このため、Ｒだけでなくどんなプログラミング言語でも、データの集まりを扱うための仕組みがあります。
多くは、**配列**や**リスト**という名前で、それらの仕組みは呼ばれています。

まずは、**プログラミングの世界で扱う一連のデータ**とは、どんなものなのかを考えてみましょう。
例えば、ここで、ある人達にテストを受けてもらい、その結果が次のようになっているとします。

|名前|点数|
|:--:|:--:|
|レナード|100|
|シェルドン|100|
|ハワード|65|
|ラジェッシュ|60|
|ペニー|3|

このテストの点数についての、最高点、最低点、平均点、中央値、標準偏差等を知るためには、
テスト結果の一連の点数が必要です。
この一連のひとまとまりを扱うために、Rではベクトルという仕組みがあるのです。

### ベクトルの作成

では、ここで、実際にベクトルを作りましょう。
ベクトルの作成には、`c()`関数を使います。`c()`関数の `c` はCombine（結合）の `c` です。
`c()`関数は、一連の複数データを引数として渡してベクトルを作成します。
すなわち、`,`カンマを使って、複数の引数として一連のデータを渡します。

```{r}
# c()関数を使って一連のデータからベクトルを作成する
c(99, 100, 65, 60, 3)
```

実行すると、すぐに結果としてベクトルが表示されます。
その単純な数字の並び、それがベクトルです。

ここで、変数の項目を思い出してください。
今作成したベクトルは、変数に代入していないので、
コンピューター上に保持されていません。

ここで、練習問題です。
このテスト結果のベクトルを`results`という変数に代入し、このデータを保持して見てください。


```{r}
# ベクトルを変数に代入してデータを保持する
results <- c(99, 100, 65, 60, 3)
```

さて、ここでチェックです。

- 履歴機能は使えましたか？
- `<-`を上手に入力できましたか？

### データの型とベクトルの性質

右上ペインのEnvironmentタブを見てみましょう。
そこに、`results`変数が加わっているはずでが、
変数の内容は、先ほどの単純な数字の10や21と異なり、次の様になっているはずです。

```
num [1:5] 98 100 80 80 25
```

この情報は、３つの部分から構成されています。
はじめの`num`は、number即ち数値を省略したものであり、
このデータは数値データですという**データの型**を表しています。


次の`[1:5]`は、このベクトルは１番から５番のデータで構成されていることを表しています。
最後は、実際のデータの中身が表示されています。

まとめると、ベクトルのEnvironmentタブでの表現は、次の３つの部分で構成されているのです。

- データの型
- データの大きさ
- データの中身

ここで、少しだけより正確にベクトルの事を把握しましょう。

プログラミングの世界では、データには必ず**型**というものが存在します。
直感的に把握できるように、今、ベクトルを作ったテスト結果の点数は、**数値**という型になります。
一方で、そのテストを受けた人たちの名前があります。
例えば、「レナード」や「シェルダン」ですが、これらは、**文字列**という型になります。
更には、どのプログラミングの教科書を見たとしても、もっとたくさんの様々な型についての説明があるはずです。
なんだか面倒な話になってきたなぁと感じおられる方もしれません。

しかし、何故このような型があるのかを想像してみると、そんなに難しい話ではないと感じるようになれると思います。

プログラミングを行う時、必ず、その処理によって何かの解決策を得るためにプログラムを書いています。
例えば、上記のテストの結果についてでは、その結果から平均点を知るためにプログラムを書くかもしれません。
そして、平均点を求めるために必要なのは各点数を表現している**数値**が必要になります。
一方、もし、平均点を求めるための処理に受験生の名前である**文字列**を与えると何が起こるのでしょうか？
技巧的には、何らかの計算結果が出てくるかもしれませんが、一般的な平均の意味論的にはナンセンスです。
文字列に対する処理としては、例えば、このテストを「シェルダン」は受けたか？というプログラムを書くかもしれません。
この名前を探している処理に、数値を与える事は、「もともと見つかるはずがない」というよりも、その処理自体に意味がありません。

現代的なプログラミング言語の中での型の存在意義は、
データの型を認識することで、そのデータの特徴に沿った扱い方を意識できるようになる事だと思います。

単純に言えば、データの型が違うと処理処理できる事が違うということです。

さて、このようにデータには型があるわけですが、
ベクトルのデータは、全てデータの型が同じでなければならないというルールがあります。












単純に、ひとまとまりのデータ

ベクトルは、`c()`という関数で作成されます。
この`c()`を使って、次の幾つかの数字でベクトルを作成してみます。





具体的に、例えば、98 100 80 80 25という５つの数字があったとします。















## データフレイム

